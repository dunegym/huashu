# 多通道LED光源日间照明模式优化算法框架

## 1. 问题建模

### 1.1 光谱合成模型
多通道光源的总光谱为各通道光谱的加权线性叠加：

```
S_total(λ) = w1×S_red(λ) + w2×S_green(λ) + w3×S_blue(λ) + w4×S_WW(λ) + w5×S_CW(λ)
```

其中：
- w1, w2, w3, w4, w5 为各通道权重系数（优化变量）
- 权重约束：0 ≤ wi ≤ 1, i = 1,2,3,4,5

### 1.2 优化目标与约束
- **主要目标**：最大化保真度指数 Rf（接近100）
- **约束条件**：
  - CCT ∈ [5500K, 7000K]（6500K ± 500K）
  - Rg ∈ [95, 105]
  - Rf > 88
  - mel-DER 计算并报告

## 2. 算法设计思路

### 2.1 基于遗传算法的多目标优化
参考文档采用遗传算法+惩罚函数的方法，适用于本问题：

#### 适应度函数设计
```
F(w) = f(w) + ∑Rj × gj(w)
```

**目标函数**：
```
f(w) = Rf  // 最大化保真度指数
```

**约束惩罚函数**：
```
g1(w) = max(0, |CCT - 6500| - 500) / 500     // CCT约束
g2(w) = max(0, 95 - Rg) + max(0, Rg - 105)  // Rg约束  
g3(w) = max(0, 88 - Rf)                      // Rf最低要求
```

### 2.2 算法参数设置
- 种群规模：40-50个个体
- 染色体精度：25位
- 惩罚参数：Rj = 2000（大正数）
- 交叉概率：0.7
- 变异概率：0.1
- 最大迭代次数：10000代
- 收敛条件：连续500代适应度无改善

## 3. 算法实现流程

### 3.1 初始化阶段
1. **数据预处理**
   - 加载五个通道的SPD数据
   - 波长范围统一至380-780nm，间隔5nm
   - SPD数据归一化处理

2. **初始种群生成**
   - 随机生成权重组合 w = [w1, w2, w3, w4, w5]
   - 确保权重和归一化：∑wi = 1

### 3.2 优化迭代过程

#### 主循环结构：
```python
for generation in range(max_generations):
    for individual in population:
        # 1. 光谱合成
        spectrum = synthesize_spectrum(weights, channel_spds)
        
        # 2. 光学参数计算
        cct = calculate_CCT(spectrum)
        rf = calculate_Rf(spectrum)  
        rg = calculate_Rg(spectrum)
        mel_der = calculate_mel_DER(spectrum)
        
        # 3. 适应度评估
        fitness = evaluate_fitness(rf, cct, rg)
        
    # 4. 遗传操作
    population = genetic_operations(population, fitness_scores)
    
    # 5. 收敛检查
    if convergence_check():
        break
```

### 3.3 关键计算模块

#### 光谱合成函数
```python
def synthesize_spectrum(weights, channel_spds):
    """合成总光谱"""
    total_spd = np.zeros_like(channel_spds[0])
    for i, weight in enumerate(weights):
        total_spd += weight * channel_spds[i]
    return total_spd / np.sum(total_spd)  # 归一化
```

#### 适应度评估函数
```python
def evaluate_fitness(rf, cct, rg):
    """计算适应度值"""
    # 目标函数：最大化Rf
    objective = rf / 100.0  # 归一化
    
    # 约束惩罚
    penalty = 0
    if abs(cct - 6500) > 500:
        penalty += 2000 * (abs(cct - 6500) - 500) / 500
    if rg < 95 or rg > 105:
        penalty += 2000 * max(95-rg, rg-105) / 10
    if rf < 88:
        penalty += 2000 * (88-rf) / 12
        
    return objective - penalty  # 最大化适应度
```

### 3.4 遗传算子设计

#### 选择策略
- 采用轮盘赌选择或锦标赛选择
- 保留精英个体（精英保存策略）

#### 交叉操作
```python
def crossover(parent1, parent2):
    """实数编码的均匀交叉"""
    alpha = 0.5
    child1 = alpha * parent1 + (1-alpha) * parent2
    child2 = (1-alpha) * parent1 + alpha * parent2
    # 权重归一化
    child1 = child1 / np.sum(child1)
    child2 = child2 / np.sum(child2)
    return child1, child2
```

#### 变异操作
```python
def mutation(individual, mutation_rate=0.1):
    """高斯变异"""
    if random.random() < mutation_rate:
        noise = np.random.normal(0, 0.05, len(individual))
        individual = np.maximum(0, individual + noise)
        individual = individual / np.sum(individual)  # 重新归一化
    return individual
```

## 4. 算法优化策略

### 4.1 多阶段优化
1. **粗搜索阶段**：大变异率快速探索
2. **精搜索阶段**：小变异率局部优化
3. **微调阶段**：针对最优解附近精细调整

### 4.2 约束处理改进
- 动态惩罚参数：随迭代次数增加惩罚强度
- 可行解修复：将不可行解投影到可行域边界

### 4.3 收敛加速
- 自适应交叉变异率
- 多点启动避免局部最优
- 历史最优解记录与追踪

## 5. 结果输出与评估

### 5.1 最优解输出
```python
# 最优权重组合
optimal_weights = [w1_opt, w2_opt, w3_opt, w4_opt, w5_opt]

# 对应光学参数
results = {
    'CCT': cct_value,
    'Rf': rf_value, 
    'Rg': rg_value,
    'mel_DER': mel_der_value,
    'weights': optimal_weights
}
```

### 5.2 性能验证
- 检查所有约束条件是否满足
- 对比理论最优值分析收敛性
- 敏感性分析验证解的稳定性

## 6. 实现注意事项

### 6.1 数值稳定性
- 避免权重为负值或过大
- SPD积分计算采用梯形法则
- 浮点运算精度控制

### 6.2 算法调优
- 根据问题规模调整种群大小
- 监控收敛曲线调整参数
- 多次独立运行验证结果一致性

### 6.3 扩展性考虑
- 算法框架可扩展至其他光谱质量指标
- 支持不同时段照明模式切换
- 可集成硬件约束（功率限制等）

## 7. 预期结果

通过该算法框架，预期能够找到满足以下指标的最优权重组合：
- **CCT**: 6500K ± 500K范围内
- **Rf**: > 90（力争接近100）
- **Rg**: 95-105之间
- **mel-DER**: 提供定量数值用于生理节律评估

该方案既保证了算法的理论严谨性，又具备良好的工程可实现性。